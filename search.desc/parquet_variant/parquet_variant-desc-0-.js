searchState.loadedDescShard("parquet_variant", 0, "Implementation of Variant Binary Encoding from Apache …\nVariant value. May contain references to metadata and value\nEncodes the Variant Metadata, see the Variant spec file …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNote: This is <code>offset_size_minus_one</code> + 1\nDecodes a Binary from the value section of a variant.\nDecodes a Date from the value section of a variant.\nDecodes a Decimal16 from the value section of a variant.\nDecodes a Decimal4 from the value section of a variant.\nDecodes a Decimal8 from the value section of a variant.\nDecodes a Double from the value section of a variant.\nDecodes a Float from the value section of a variant.\nDecodes an Int16 from the value section of a variant.\nDecodes an Int32 from the value section of a variant.\nDecodes an Int64 from the value section of a variant.\nDecodes an Int8 from the value section of a variant.\nDecodes a long string from the value section of a variant.\nDecodes a short string from the value section of a variant.\nDecodes a TimestampMicros from the value section of a …\nDecodes a TimestampNtzMicros from the value section of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nExtracts the basic type from a header byte\nExtract the primitive type from a Variant value-metadata …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTo be used in <code>map_err</code> when unpacking an integer from a …\nTo be used in <code>map_err</code> when unpacking an integer from a …\nHelper to get a &amp;str from a slice based on range, if it’…\nVariant value. May contain references to metadata and value\nEncodes the Variant Metadata, see the Variant spec file …\nConverts this variant to a <code>bool</code> if possible.\nView the raw bytes (needed by very low-level decoders)\nConverts this variant to a <code>DateTime&lt;Utc&gt;</code> if possible.\nConverts this variant to tuple with a 16-byte unscaled …\nConverts this variant to tuple with a 4-byte unscaled …\nConverts this variant to tuple with an 8-byte unscaled …\nConverts this variant to an <code>f32</code> if possible.\nConverts this variant to an <code>f64</code> if possible.\nConverts this variant to an <code>i16</code> if possible.\nConverts this variant to an <code>i32</code> if possible.\nConverts this variant to an <code>i64</code> if possible.\nConverts this variant to an <code>i8</code> if possible.\nConverts this variant to a <code>NaiveDate</code> if possible.\nConverts this variant to a <code>NaiveDateTime</code> if possible.\nConverts this variant to <code>()</code> if it is null.\nConverts this variant to a <code>&amp;str</code> if possible.\nConverts this variant to a <code>&amp;[u8]</code> if possible.\nGet the dictionary size\nGet all key-names as an Iterator of strings\nReturns the argument unchanged.\nGet the key-name by index\nGets the field using an offset (Range) - helper method to …\nGet a single offset by index\nHelper method to get the offset start and end range for a …\nCalls <code>U::from(self)</code>.\nIs the array of zero length\nWhether the dictionary keys are sorted and unique\nReturn the length of this array\nNote: This is <code>offset_size_minus_one</code> + 1\nGet the offsets as an iterator\nBuild from the <code>offset_size_minus_one</code> bits (see spec).\nTries to construct the variant metadata header, which has …\nParse the buffers and return the appropriate variant.\nReturn one unsigned little-endian value from <code>bytes</code>.")